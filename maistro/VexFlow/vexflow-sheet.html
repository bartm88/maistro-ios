<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        html, body {
            background: transparent;
            overflow: hidden;
        }
        #output {
            background: transparent;
        }
    </style>
    <script src="vexflow.js"></script>
</head>
<body>
    <div id="output"></div>

    <script>
        const { Factory, Renderer, Stave, StaveNote, Voice, Formatter, Accidental, StaveTie } = Vex.Flow;

        let renderer = null;
        let context = null;

        // Main render function - supports both simple notation and JSON passage
        // scalingFactor: 0.0-1.0, computed as min(1.0, screenWidth / 900.0)
        function renderNotation(notationString, width, height, timeSignature = '4/4', scalingFactor = 1.0) {
            console.log('[VexFlow] renderNotation called:', { notationString: notationString.substring(0, 50), width, height, timeSignature, scalingFactor });

            const container = document.getElementById('output');
            container.innerHTML = '';

            // Clamp scaling factor between 0.5 and 1.0
            const scale = Math.max(0.5, Math.min(1.0, scalingFactor));

            // Try to parse as JSON passage first
            try {
                if (notationString.startsWith('{') || notationString.startsWith('[')) {
                    const passage = JSON.parse(notationString);
                    renderPassage(passage, container, width, height, timeSignature, scale);
                    return;
                }
            } catch (e) {
                console.log('[VexFlow] Not JSON, parsing as simple notation');
            }

            // Fall back to simple notation parsing
            renderSimpleNotation(notationString, container, width, height, timeSignature, scale);
        }

        const FIRST_MEASURE_ADDITIONAL_WIDTH = 50;
        const MEASURE_HEIGHT = 75;
        const MEASURE_Y_OFFSET = 0;

        // Compute measure dimensions based on max glyphs in any measure
        function computeMeasureDimensions(measures) {
            let maxGlyph = 0;

            measures.forEach((measure) => {
                let glyphsInMeasure = 0;
                measure.elements.forEach((element) => {
                    if (element.element.Note) {
                        glyphsInMeasure += element.element.Note.noteDurations.length;
                    }
                    if (element.element.Rest) {
                        glyphsInMeasure += element.element.Rest.restDurations.length;
                    }
                });
                if (glyphsInMeasure > maxGlyph) {
                    maxGlyph = glyphsInMeasure;
                }
            });

            // Max 3 measures per line, fewer if measures have many glyphs
            if (maxGlyph <= 8) {
                return { measureWidth: 190, measuresPerLine: 3 };
            } else if (maxGlyph <= 16) {
                return { measureWidth: 285, measuresPerLine: 2 };
            } else {
                return { measureWidth: 560, measuresPerLine: 1 };
            }
        }

        // Calculate duration in subdivisions for a DenominatorDots object
        function getDurationInSubdivisions(duration, subdivisionDenominator) {
            const baseDuration = subdivisionDenominator / duration.denominator;
            switch (duration.dots) {
                case 0: return baseDuration;
                case 1: return baseDuration * 3 / 2;
                case 2: return baseDuration * 7 / 4;
                default: return baseDuration;
            }
        }

        // Get total duration of an element in subdivisions
        function getElementDuration(element, subdivisionDenominator) {
            if (element.element.Note) {
                return element.element.Note.noteDurations.reduce((sum, d) =>
                    sum + getDurationInSubdivisions(d, subdivisionDenominator), 0);
            } else if (element.element.Rest) {
                return element.element.Rest.restDurations.reduce((sum, d) =>
                    sum + getDurationInSubdivisions(d, subdivisionDenominator), 0);
            }
            return 0;
        }

        // Group notes by start time and duration to form chords, then assign to voices
        // Notes with same start time AND same duration become a chord (single StaveNote with multiple keys)
        // Notes with different start times or durations that overlap go to different voices
        function assignNotesToVoices(elements, subdivisionDenominator, totalSubdivisions) {
            // First, group notes by start time and duration to form chords
            const chordGroups = new Map(); // key: "startTime-duration", value: [elements]
            const restElements = [];

            elements.forEach(element => {
                if (element.element.Note) {
                    const startTime = element.startSubdivision;
                    const duration = getElementDuration(element, subdivisionDenominator);
                    const key = `${startTime}-${duration}`;

                    if (!chordGroups.has(key)) {
                        chordGroups.set(key, []);
                    }
                    chordGroups.get(key).push(element);
                } else {
                    restElements.push(element);
                }
            });

            // Convert chord groups to chord events
            const chordEvents = [];
            chordGroups.forEach((noteElements, key) => {
                const [startTime, duration] = key.split('-').map(Number);
                chordEvents.push({
                    type: 'chord',
                    noteElements: noteElements,
                    startSubdivision: startTime,
                    duration: duration
                });
            });

            // Add rest events
            restElements.forEach(element => {
                const startTime = element.startSubdivision;
                const duration = getElementDuration(element, subdivisionDenominator);
                chordEvents.push({
                    type: 'rest',
                    element: element,
                    startSubdivision: startTime,
                    duration: duration
                });
            });

            // Sort by start time
            chordEvents.sort((a, b) => a.startSubdivision - b.startSubdivision);

            // Now assign chord events to voices based on overlap
            const voices = [];

            chordEvents.forEach(event => {
                const startTime = event.startSubdivision;
                const endTime = startTime + event.duration;

                // Find a voice that's free at this start time
                let assignedVoice = null;
                for (const voice of voices) {
                    if (voice.endTime <= startTime) {
                        assignedVoice = voice;
                        break;
                    }
                }

                // If no free voice, create a new one
                if (!assignedVoice) {
                    assignedVoice = { endTime: 0, events: [] };
                    voices.push(assignedVoice);
                }

                assignedVoice.events.push(event);
                assignedVoice.endTime = endTime;
            });

            return voices;
        }

        // Convert subdivision duration to VexFlow duration string
        function subdivisionsToDuration(subdivisions, subdivisionDenominator) {
            // Common durations based on subdivision denominator (usually 8)
            // subdivisions: 8 = whole, 6 = dotted half, 4 = half, 3 = dotted quarter,
            // 2 = quarter, 1.5 = dotted eighth, 1 = eighth
            const ratio = subdivisions / subdivisionDenominator;

            if (ratio >= 1) return { denominator: 1, dots: 0 }; // whole
            if (ratio >= 0.75) return { denominator: 2, dots: 1 }; // dotted half
            if (ratio >= 0.5) return { denominator: 2, dots: 0 }; // half
            if (ratio >= 0.375) return { denominator: 4, dots: 1 }; // dotted quarter
            if (ratio >= 0.25) return { denominator: 4, dots: 0 }; // quarter
            if (ratio >= 0.1875) return { denominator: 8, dots: 1 }; // dotted eighth
            if (ratio >= 0.125) return { denominator: 8, dots: 0 }; // eighth
            if (ratio >= 0.0625) return { denominator: 16, dots: 0 }; // sixteenth
            return { denominator: 16, dots: 0 }; // default to sixteenth
        }

        // Fill gaps in a voice with rests
        function fillVoiceWithRests(voiceEvents, totalSubdivisions, subdivisionDenominator) {
            const filledEvents = [];
            let currentPosition = 0;

            voiceEvents.forEach(event => {
                // Fill gap before this event with rests
                while (currentPosition < event.startSubdivision) {
                    const gap = event.startSubdivision - currentPosition;
                    const restDuration = subdivisionsToDuration(gap, subdivisionDenominator);
                    const restSubdivisions = getDurationInSubdivisions(restDuration, subdivisionDenominator);

                    filledEvents.push({
                        type: 'filler-rest',
                        duration: restDuration,
                        startSubdivision: currentPosition
                    });
                    currentPosition += restSubdivisions;
                }

                // Add the actual event (chord or rest)
                filledEvents.push(event);
                currentPosition = event.startSubdivision + event.duration;
            });

            // Fill remaining time with rests
            while (currentPosition < totalSubdivisions) {
                const gap = totalSubdivisions - currentPosition;
                const restDuration = subdivisionsToDuration(gap, subdivisionDenominator);
                const restSubdivisions = getDurationInSubdivisions(restDuration, subdivisionDenominator);

                filledEvents.push({
                    type: 'filler-rest',
                    duration: restDuration,
                    startSubdivision: currentPosition
                });
                currentPosition += restSubdivisions;
            }

            return filledEvents;
        }

        // Render a discrete passage (JSON format from Swift)
        function renderPassage(passage, container, width, height, timeSignature, scalingFactor) {
            const measures = passage.measures || [];
            console.log('[VexFlow] Rendering passage with', measures.length, 'measures, scale:', scalingFactor);

            const { measureWidth, measuresPerLine } = computeMeasureDimensions(measures);
            const numLines = Math.max(1, Math.ceil(measures.length / measuresPerLine));
            const requiredHeight = MEASURE_HEIGHT * numLines;

            console.log('[VexFlow] Layout:', { measureWidth, measuresPerLine, numLines, requiredHeight });

            // Parse time signature
            const [tsNum, tsDenom] = timeSignature.split('/').map(Number);

            // Apply scaling factor to canvas dimensions
            const scaledWidth = width * scalingFactor;
            const scaledHeight = Math.max(height, requiredHeight) * scalingFactor;

            const factory = new Factory({
                renderer: { elementId: 'output', width: scaledWidth, height: scaledHeight }
            });

            const score = factory.EasyScore();
            score.set({ time: timeSignature });

            // Track last note of each measure for cross-measure ties
            let lastNoteOfPreviousMeasure = null;
            // Track pending cross-measure ties (from last note of prev measure to first note of current)
            const crossMeasureTies = [];

            measures.forEach((measure, measureIndex) => {
                const subdivisionDenominator = measure.subdivisionDenominator || 8;
                const totalSubdivisions = tsNum * subdivisionDenominator / tsDenom;

                // Assign notes to voices based on overlap
                const voiceAssignments = assignNotesToVoices(
                    measure.elements,
                    subdivisionDenominator,
                    totalSubdivisions
                );

                console.log('[VexFlow] Measure', measureIndex, 'has', voiceAssignments.length, 'voices');

                // Build VexFlow voices
                const vexVoices = [];
                let firstNoteOfMeasure = null;
                let lastNoteOfMeasure = null;

                voiceAssignments.forEach((voiceData, voiceIndex) => {
                    const voiceNotes = [];
                    let tieStartNote = null;

                    // Fill voice with events (chords, rests, and gap-filling rests)
                    const filledEvents = fillVoiceWithRests(
                        voiceData.events,
                        totalSubdivisions,
                        subdivisionDenominator
                    );

                    filledEvents.forEach(event => {
                        if (event.type === 'chord') {
                            // Chord: multiple notes at same time with same duration
                            const noteElements = event.noteElements;

                            // Get the first note's duration info (all notes in chord have same duration)
                            const firstNote = noteElements[0].element.Note;
                            const isTiedFromPrevious = noteElements.some(el => el.tiedFromPrevious === true);

                            // Process each duration (for tied notes)
                            firstNote.noteDurations.forEach((duration, durationIndex) => {
                                // Build EasyScore notation string
                                const durationStr = `${duration.denominator}${'.'.repeat(duration.dots)}`;

                                let noteStr;
                                if (noteElements.length === 1) {
                                    // Single note: "B4/4"
                                    noteStr = `${noteElements[0].element.Note.noteName}/${durationStr}`;
                                } else {
                                    // Chord: "(B4 D4 F4)/4"
                                    const noteNames = noteElements
                                        .map(el => el.element.Note.noteName)
                                        .sort((a, b) => {
                                            // Sort by octave first, then by note
                                            const octA = parseInt(a.match(/\d+$/)[0]);
                                            const octB = parseInt(b.match(/\d+$/)[0]);
                                            if (octA !== octB) return octA - octB;
                                            const noteOrder = ['C', 'D', 'E', 'F', 'G', 'A', 'B'];
                                            const noteA = a.match(/^[A-G][#b]?/)[0];
                                            const noteB = b.match(/^[A-G][#b]?/)[0];
                                            const baseA = noteA[0];
                                            const baseB = noteB[0];
                                            return noteOrder.indexOf(baseA) - noteOrder.indexOf(baseB);
                                        })
                                        .join(' ');
                                    noteStr = `(${noteNames})/${durationStr}`;
                                }

                                // Use EasyScore to create the note(s)
                                const staveNotes = score.notes(noteStr);
                                const staveNote = staveNotes[0];

                                // Track first note of measure for cross-measure ties (only from voice 0)
                                if (voiceIndex === 0 && firstNoteOfMeasure === null) {
                                    firstNoteOfMeasure = staveNote;

                                    if (isTiedFromPrevious && lastNoteOfPreviousMeasure) {
                                        crossMeasureTies.push({
                                            from: lastNoteOfPreviousMeasure,
                                            to: staveNote
                                        });
                                    }
                                }

                                // Tie within same note element (multiple durations)
                                if (durationIndex > 0 && tieStartNote) {
                                    factory.StaveTie({ from: tieStartNote, to: staveNote });
                                }

                                tieStartNote = staveNote;
                                if (voiceIndex === 0) {
                                    lastNoteOfMeasure = staveNote;
                                }
                                voiceNotes.push(...staveNotes);
                            });
                        } else if (event.type === 'rest') {
                            // Original rest from the passage
                            const rest = event.element.element.Rest;
                            rest.restDurations.forEach((duration) => {
                                const restStr = `B4/${duration.denominator}/r${'.'.repeat(duration.dots)}`;
                                const staveNotes = score.notes(restStr);
                                voiceNotes.push(...staveNotes);
                            });
                            tieStartNote = null;
                        } else if (event.type === 'filler-rest') {
                            // Gap-filling rest
                            const duration = event.duration;
                            if (typeof duration === 'object') {
                                const restStr = `B4/${duration.denominator}/r${'.'.repeat(duration.dots)}`;
                                const staveNotes = score.notes(restStr);
                                voiceNotes.push(...staveNotes);
                            }
                            tieStartNote = null;
                        }
                    });

                    if (voiceNotes.length > 0) {
                        vexVoices.push(score.voice(voiceNotes));
                    }
                });

                // Save last note of this measure for potential cross-measure tie
                lastNoteOfPreviousMeasure = lastNoteOfMeasure;

                const lineIndex = Math.floor(measureIndex / measuresPerLine);
                const positionInLine = measureIndex % measuresPerLine;
                const y = MEASURE_Y_OFFSET + MEASURE_HEIGHT * lineIndex;

                // First measure of each line gets clef (and time signature on very first measure)
                if (positionInLine === 0) {
                    const system = factory.System({
                        width: FIRST_MEASURE_ADDITIONAL_WIDTH + measureWidth,
                        x: 10,
                        y: y
                    });
                    const stave = system.addStave({ voices: vexVoices }).addClef('treble');
                    if (measureIndex === 0) {
                        stave.addTimeSignature(timeSignature);
                    }
                } else {
                    const system = factory.System({
                        width: measureWidth,
                        x: 10 + FIRST_MEASURE_ADDITIONAL_WIDTH + measureWidth * positionInLine,
                        y: y
                    });
                    system.addStave({ voices: vexVoices });
                }
            });

            // Draw cross-measure ties after all measures are set up
            crossMeasureTies.forEach(tie => {
                factory.StaveTie({ from: tie.from, to: tie.to });
            });

            // Scale the context before drawing
            factory.getContext().scale(scalingFactor, scalingFactor);
            factory.draw();
        }

        // Render simple comma-separated notation string
        function renderSimpleNotation(notationString, container, width, height, timeSignature, scalingFactor) {
            // Apply scaling factor to canvas dimensions
            const scaledWidth = width * scalingFactor;
            const scaledHeight = height * scalingFactor;

            renderer = new Renderer(container, Renderer.Backends.SVG);
            renderer.resize(scaledWidth, scaledHeight);
            context = renderer.getContext();
            context.setFont('Arial', 10);

            // Scale the context
            context.scale(scalingFactor, scalingFactor);

            const staveWidth = width - 20;
            const stave = new Stave(10, 10, staveWidth);
            stave.addClef('treble');
            stave.addTimeSignature(timeSignature);
            stave.setContext(context).draw();

            const notes = parseSimpleNotation(notationString);

            if (notes.length > 0) {
                const [num, denom] = timeSignature.split('/').map(Number);
                const voice = new Voice({ num_beats: num, beat_value: denom }).setStrict(false);
                voice.addTickables(notes);

                new Formatter().joinVoices([voice]).format([voice], staveWidth - 80);
                voice.draw(context, stave);
            }
        }

        // Parse simple notation format: "C4/q, D4/8, E4/4., B4/4/r"
        function parseSimpleNotation(notationString) {
            if (!notationString || notationString.trim() === '') {
                return [];
            }

            const noteStrings = notationString.split(',').map(s => s.trim());
            const notes = [];

            for (const noteStr of noteStrings) {
                const parts = noteStr.split('/');
                if (parts.length < 2) continue;

                const pitchPart = parts[0].trim();
                let durationPart = parts[1].trim();
                const isRest = parts.length > 2 && parts[2].trim().toLowerCase() === 'r';

                // Parse pitch (e.g., "C4", "C#4", "Bb3")
                const pitchMatch = pitchPart.match(/^([A-Ga-g])([#bn]?)(\d)$/);
                if (!pitchMatch) continue;

                const noteName = pitchMatch[1].toLowerCase();
                const accidental = pitchMatch[2];
                const octave = pitchMatch[3];

                // Handle dots in duration
                let dots = 0;
                while (durationPart.endsWith('.')) {
                    dots++;
                    durationPart = durationPart.slice(0, -1);
                }

                // Convert duration to VexFlow format
                let duration = durationPart;
                // Map letter durations to numbers if needed
                const durationMap = { 'w': '1', 'h': '2', 'q': '4' };
                if (durationMap[duration]) {
                    duration = durationMap[duration];
                }

                // Add dots back
                duration = duration + 'd'.repeat(dots);

                // Add rest suffix if needed
                if (isRest) {
                    duration = duration + 'r';
                }

                // Create the note
                const key = noteName + '/' + octave;
                const staveNote = new StaveNote({
                    keys: [key],
                    duration: duration
                });

                // Add accidental if present
                if (accidental === '#') {
                    staveNote.addModifier(new Accidental('#'), 0);
                } else if (accidental === 'b') {
                    staveNote.addModifier(new Accidental('b'), 0);
                } else if (accidental === 'n') {
                    staveNote.addModifier(new Accidental('n'), 0);
                }

                notes.push(staveNote);
            }

            return notes;
        }

        // Render empty staff on load
        window.onload = function() {
            console.log('[VexFlow] Page loaded, rendering empty staff');
            renderNotation('', 300, 120, '4/4');
        };
    </script>
</body>
</html>
